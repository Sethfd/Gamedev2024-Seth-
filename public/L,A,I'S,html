<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-scale=1.0">
    <title>AI Leveling System with XP Pop-Up</title>
    <style>
        canvas {
            border: 1px solid black;
            position: relative;
        }
        #stats {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }
        .bar {
            width: 100px;
            height: 20px;
            background-color: #ccc;
            position: relative;
        }
        .fill {
            height: 100%;
            background-color: green;
        }
        .xp-icon {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: gold;
            border-radius: 50%;
            animation: popUp 1s forwards;
        }
        @keyframes popUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="stats">
        <div>Health: <div class="bar"><div class="fill" id="healthBar"></div></div></div>
        <div>Hunger: <div class="bar"><div class="fill" id="hungerBar"></div></div></div>
        <div>Thirst: <div class="bar"><div class="fill" id="thirstBar"></div></div></div>
        <div>Level: <span id="levelDisplay">1</span></div>
        <div>XP: <span id="xpDisplay">0</span></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const AI_SIZE = 20;
        const FOOD_SIZE = 10;
        const WATER_SIZE = 10;
        const PREY_SIZE = 15;
        const ENEMY_SIZE = 15;

        class AI {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = 2;
                this.targetFood = null;
                this.targetWater = null;
                this.targetPrey = null;
                this.health = 100;
                this.hunger = 100;
                this.thirst = 100;
                this.level = 1;
                this.xp = 0;
                this.damage = 5;
                this.xpToLevelUp = 10;
                this.xpIcons = []; // Array to hold XP icons
            }

            moveTowards(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.hypot(dx, dy);
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            gainXP(amount) {
                this.xp += amount;
                this.showXPIcon();
                if (this.xp >= this.xpToLevelUp) {
                    this.levelUp();
                }
            }

            showXPIcon() {
                const icon = document.createElement('div');
                icon.className = 'xp-icon';
                icon.style.left = `${this.x + AI_SIZE / 2 - 10}px`;
                icon.style.top = `${this.y - 30}px`; // Position above AI
                document.body.appendChild(icon);
                this.xpIcons.push(icon);

                // Remove the icon after 1 second
                setTimeout(() => {
                    icon.remove();
                    this.xpIcons.splice(this.xpIcons.indexOf(icon), 1);
                }, 1000);
            }

            levelUp() {
                this.level++;
                this.health += 20;
                this.damage += 2;
                this.xp = 0;
                this.xpToLevelUp += 10;
                document.getElementById('levelDisplay').innerText = this.level;
            }

            updateStats() {
                this.hunger -= 0.05;
                this.thirst -= 0.1;
                if (this.hunger <= 0) this.health -= 0.1;
                if (this.thirst <= 0) this.health -= 0.2;
                this.hunger = Math.max(this.hunger, 0);
                this.thirst = Math.max(this.thirst, 0);
                this.health = Math.max(this.health, 0);
            }

            draw() {
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x, this.y, AI_SIZE, AI_SIZE);
            }
        }

        class Food {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.x, this.y, FOOD_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Water {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(this.x, this.y, WATER_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Prey {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(this.x, this.y, PREY_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(this.x, this.y, ENEMY_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const ai = new AI();
        const foodItems = [];
        const waterItems = [];
        const preyItems = [];
        const enemyItems = [];

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            foodItems.push(new Food(x, y));
        });

        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            waterItems.push(new Water(x, y));
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'e') {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                enemyItems.push(new Enemy(x, y));
            }
            if (event.key === 'p') {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                preyItems.push(new Prey(x, y));
            }
        });

        function update() {
            if (foodItems.length > 0) {
                ai.targetFood = foodItems.reduce((prev, curr) => {
                    const prevDist = Math.hypot(prev.x - ai.x, prev.y - ai.y);
                    const currDist = Math.hypot(curr.x - ai.x, curr.y - ai.y);
                    return currDist < prevDist ? curr : prev;
                });
                ai.moveTowards(ai.targetFood);
            }

            if (waterItems.length > 0) {
                ai.targetWater = waterItems.reduce((prev, curr) => {
                    const prevDist = Math.hypot(prev.x - ai.x, prev.y - ai.y);
                    const currDist = Math.hypot(curr.x - ai.x, curr.y - ai.y);
                    return currDist < prevDist ? curr : prev;
                });
                ai.moveTowards(ai.targetWater);
            }

            if (preyItems.length > 0) {
                ai.targetPrey = preyItems.reduce((prev, curr) => {
                    const prevDist = Math.hypot(prev.x - ai.x, prev.y - ai.y);
                    const currDist = Math.hypot(curr.x - ai.x, curr.y - ai.y);
                    return currDist < prevDist ? curr : prev;
                });
                ai.moveTowards(ai.targetPrey);

                // Check for collision with prey
                if (Math.hypot(ai.targetPrey.x - ai.x, ai.targetPrey.y - ai.y) < AI_SIZE) {
                    ai.gainXP(5); // Gain XP for eating prey
                    preyItems.splice(preyItems.indexOf(ai.targetPrey), 1); // Remove eaten prey
                }
            }

            ai.updateStats();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            foodItems.forEach(food => food.draw());
            waterItems.forEach(water => water.draw());
            preyItems.forEach(prey => prey.draw());
            enemyItems.forEach(enemy => enemy.draw());
            ai.draw();

            // Update health, hunger, thirst, and XP bars
            document.getElementById('healthBar').style.width = ai.health + '%';
            document.getElementById('hungerBar').style.width = ai.hunger + '%';
            document.getElementById('thirstBar').style.width = ai.thirst + '%';
            document.getElementById('xpDisplay').innerText = ai.xp;
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
